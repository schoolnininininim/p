<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rigged Gamble Demo (학습용)</title>
  <style>
    body{font-family:Inter,system-ui,Arial;margin:28px;background:#f7fafc;color:#0f172a}
    .card{background:white;padding:18px;border-radius:12px;max-width:520px;margin:auto;box-shadow:0 6px 18px rgba(2,6,23,0.07)}
    h1{font-size:20px;margin:0 0 8px}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0}
    button{padding:8px 12px;border-radius:8px;border:0;background:#0ea5e9;color:white;cursor:pointer}
    input[type=number]{padding:8px;border-radius:8px;border:1px solid #e6edf3;width:120px}
    .log{background:#0f172a;color:white;padding:10px;border-radius:8px;margin-top:12px;min-height:48px}
    .warn{color:#b91c1c;font-weight:600}
  </style>
</head>
<body>
  <div class="card">
    <h1>Rigged Gamble Demo (학습/데모용)</h1>
    <p>주의: 이 프로그램은 <strong>데모용</strong>입니다. 실제 돈을 걸거나 사기/부정행위에 사용하지 마세요.</p>
    <div class="row">
      <label>잔액: </label>
      <div id="balance">1000</div>
    </div>

    <div class="row">
      <label for="bet">베팅액:</label>
      <input id="bet" type="number" min="1" value="50" />
      <button id="play">Play</button>
      <button id="reset">Reset</button>
    </div>

    <div class="row">
      <label>모드:</label>
      <select id="mode">
        <option value="rigged">Rigged (데모 기본값) — 기대값이 음수, 시간이 가면 파산으로 유도</option>
        <option value="fair">Fair (공정) — 기대값 0</option>
        <option value="house">House Edge — 약간 불리함 (일반 카지노와 유사)</option>
      </select>
    </div>

    <div class="row">
      <label>플레이 횟수:</label>
      <div id="plays">0</div>
    </div>

    <div class="log" id="log">게임 시작 — 데모용입니다.</div>

    <p style="margin-top:10px"><span class="warn">중요:</span> 이 코드는 교육/시연 목적입니다. 실제 금전 거래나 사용자에게 숨겨진 룰을 적용하는 제품으로 사용하지 마세요.</p>
  </div>

<script>
// --- 설정(원하면 조정 가능) ---
const START_BALANCE = 1000;
const MAX_FORCED_DRAIN_AFTER_PLAYS = 25; // rigged 모드에서 이 횟수 이후 강제 파산 가능성 증가
// ----------------------------

let balance = START_BALANCE;
let plays = 0;

const balanceEl = document.getElementById('balance');
const betEl = document.getElementById('bet');
const playBtn = document.getElementById('play');
const resetBtn = document.getElementById('reset');
const logEl = document.getElementById('log');
const playsEl = document.getElementById('plays');
const modeSel = document.getElementById('mode');

function updateUI(){
  balanceEl.textContent = Math.max(0, Math.round(balance));
  playsEl.textContent = plays;
}

function appendLog(text){
  logEl.textContent = text + '\n\n' + logEl.textContent;
}

function playRound(){
  const bet = Math.max(1, Math.floor(Number(betEl.value) || 0));
  if(bet > balance){
    appendLog('베팅액이 잔액보다 큽니다.');
    return;
  }

  const mode = modeSel.value;
  plays++;

  // 난수
  const r = Math.random();
  let resultText = '';

  if(mode === 'fair'){
    // 공정: 50%로 double, 50%로 잃음 -> 기대값 0
    if(r < 0.5){ balance += bet; resultText = `승리! +${bet}`; }
    else { balance -= bet; resultText = `패배... -${bet}`; }
  } else if(mode === 'house'){
    // 일반 카지노처럼 약간 불리함: 승리확률 48%, 승리 시 +bet, 실패 시 -bet
    if(r < 0.48){ balance += bet; resultText = `승리! +${bet}`; }
    else { balance -= bet; resultText = `패배... -${bet}`; }
  } else {
    // rigged 모드: 플레이를 계속하면 파산 확률이 올라가도록 설계
    // 1) 기본 승리확률은 45%로 낮음
    // 2) 플레이 횟수가 많아질수록 '강제 드레인' 확률이 증가해서 남은 전액을 잃을 수 있음

    const baseWinProb = 0.45;
    // 강제 드레인 확률: plays가 증가할수록 선형 증가(최대 60%)
    const drainProb = Math.min(0.6, Math.max(0, (plays - MAX_FORCED_DRAIN_AFTER_PLAYS) * 0.03));

    // 우선 강제 드레인 체크
    if(Math.random() < drainProb){
      // 강제 드레인 발생: 잔액 전량을 잃음
      const lost = balance;
      balance = 0;
      resultText = `강제 드레인 발생! 잔액 전액 -${Math.round(lost)} (데모용)`;
    } else {
      // 정상 결과: 낮은 승리확률, 패배 시 더 큰 손실(하우스 마진)
      if(r < baseWinProb){
        // 작은 이득: 승리하면 베팅의 0.8배 추가 (승리 보상은 보수적으로 조정)
        const gain = Math.floor(bet * 0.8);
        balance += gain;
        resultText = `소액 승리 +${gain}`;
      } else {
        // 패배 시 더 큰 손실: 베팅의 1.2배
        const loss = Math.ceil(bet * 1.2);
        balance -= loss;
        resultText = `패배 -${loss}`;
      }
    }
  }

  // 잔액 최소값 처리
  if(balance < 0) balance = 0;

  updateUI();
  appendLog(`[플레이 ${plays}] ${resultText} — 잔액: ${Math.round(balance)}`);
}

playBtn.addEventListener('click', () => {
  playRound();
});

resetBtn.addEventListener('click', () => {
  balance = START_BALANCE; plays = 0; updateUI(); appendLog('리셋됨.');
});

updateUI();
</script>
</body>
</html>